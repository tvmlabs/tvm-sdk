#[allow(dead_code)]
use std::collections::HashMap;
use std::time::Instant;

use base64ct::Encoding as bEncoding;
use serde::Deserialize;
use serde_derive::Serialize;
use tvm_types::Cell;
use tvm_vm::executor::zk_stuff::error::ZkCryptoError;
use tvm_vm::executor::zk_stuff::zk_login::CanonicalSerialize;
use tvm_vm::executor::zk_stuff::zk_login::JWK;
use tvm_vm::executor::zk_stuff::zk_login::JwkId;
use tvm_vm::executor::zk_stuff::zk_login::ZkLoginInputs;
use tvm_vm::utils::pack_data_to_cell;

use crate::instructions_tests::test_framework::Expects;
use crate::instructions_tests::test_framework::test_case_with_refs;

#[derive(Debug, Deserialize)]
pub struct JwtData {
    pub jwt: String,
    pub user_pass_to_int_format: String,
    pub ephemeral_key_pair: EphemeralKeyPair,
    pub zk_addr: String,
    pub zk_proofs: ZkProofs,
    pub extended_ephemeral_public_key: String,
}

#[derive(Debug, Deserialize)]
pub struct EphemeralKeyPair {
    pub keypair: Keypair,
}

#[derive(Debug, Deserialize)]
pub struct Keypair {
    pub public_key: HashMap<String, u8>,
    pub secret_key: HashMap<String, u8>,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ZkProofs {
    pub proof_points: ProofPoints,
    pub iss_base64_details: IssBase64Details,
    pub header_base64: String,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct ProofPoints {
    pub a: Vec<String>,
    pub b: Vec<Vec<String>>,
    pub c: Vec<String>,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct IssBase64Details {
    pub value: String,
    pub index_mod4: i32,
}

pub fn prepare_proof_and_public_key_cells_for_stack(
    eph_pubkey: &Vec<u8>,
    zk_login_inputs: &ZkLoginInputs,
    all_jwk: &HashMap<JwkId, JWK>,
    max_epoch: u64,
) -> (Cell, Cell) {
    let (iss, kid) = (zk_login_inputs.get_iss().to_string(), zk_login_inputs.get_kid().to_string());
    println!("kid = {}", kid);
    println!("all_jwk = {:?}", all_jwk);

    let jwk = all_jwk
        .get(&JwkId::new(iss.clone(), kid.clone()))
        .ok_or_else(|| ZkCryptoError::GeneralError(format!("JWK not found ({} - {})", iss, kid)))
        .unwrap();

    // Decode modulus to bytes.
    let modulus = base64ct::Base64UrlUnpadded::decode_vec(&jwk.n)
        .map_err(|_| ZkCryptoError::GeneralError("Invalid Base64 encoded jwk modulus".to_string()))
        .unwrap();

    let proof = &zk_login_inputs.get_proof().as_arkworks().unwrap();
    let public_inputs =
        &[zk_login_inputs.calculate_all_inputs_hash(&eph_pubkey, &modulus, max_epoch).unwrap()];

    let mut proof_as_bytes = vec![];
    proof.serialize_compressed(&mut proof_as_bytes).unwrap();
    println!("proof_as_bytes : {:?}", proof_as_bytes);
    println!("proof_as_bytes len: {:?}", proof_as_bytes.len());

    let proof_cell = pack_data_to_cell(&proof_as_bytes, &mut 0).unwrap();

    let mut public_inputs_as_bytes = vec![];
    public_inputs.serialize_compressed(&mut public_inputs_as_bytes).unwrap();
    println!("public_inputs_as_bytes : {:?}", public_inputs_as_bytes);
    println!("public_inputs_as_bytes len : {:?}", public_inputs_as_bytes.len());

    let public_inputs_cell = pack_data_to_cell(&public_inputs_as_bytes, &mut 0).unwrap();

    (proof_cell, public_inputs_cell)
}

pub fn single_vrgrth16(
    eph_pubkey: &Vec<u8>,
    zk_login_inputs: &ZkLoginInputs,
    all_jwk: &HashMap<JwkId, JWK>,
    verification_key_id: u32,
    max_epoch: u64,
) -> u128 {
    let (proof_cell, public_inputs_cell) = prepare_proof_and_public_key_cells_for_stack(
        eph_pubkey,
        zk_login_inputs,
        all_jwk,
        max_epoch,
    );

    let mut code = "PUSHREF \n".to_string();
    code = code + "PUSHREF \n";
    code = code + "PUSHINT " + &*verification_key_id.to_string() + "\n";
    code = code + "VERGRTH16";

    let start: Instant = Instant::now();
    test_case_with_refs(code.as_str(), vec![proof_cell.clone(), public_inputs_cell.clone()])
        .expect_success();
    start.elapsed().as_micros()
}

pub fn secret_key_from_integer_map(key_data: HashMap<String, u8>) -> Vec<u8> {
    let mut vec: Vec<u8> = Vec::new();
    for i in 0..=31 {
        if let Some(value) = key_data.get(&i.to_string()) {
            vec.push(value.clone());
        }
    }
    return vec;
}
