// Copyright 2018-2021 TON Labs LTD.
//
// Licensed under the SOFTWARE EVALUATION License (the "License"); you may not
// use this file except in compliance with the License.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific TON DEV software governing permissions and
// limitations under the License.
//

use std::sync::Arc;

use serde_json::Value;
use tvm_block::Message;
use tvm_block::MsgAddressInt;

use super::ThreadIdentifier;
use crate::abi::Abi;
use crate::abi::ParamsOfDecodeMessageBody;
use crate::abi::decode_message_body;
use crate::boc::internal::DeserializedObject;
use crate::boc::internal::deserialize_object_from_boc;
use crate::client::ClientContext;
use crate::encoding::base64_decode;
use crate::encoding::hex_decode;
use crate::error::ClientError;
use crate::error::ClientResult;
use crate::processing::Error;
use crate::processing::internal::get_message_expiration_time;
use crate::processing::types::ProcessingEvent;
use crate::utils::json::JsonHelper;

#[derive(Serialize, Deserialize, ApiType, Default, Debug, Clone)]
pub struct ParamsOfSendMessage {
    /// Message BOC.
    pub message: String,

    /// Optional message ABI.
    ///
    /// If this parameter is specified and the message has the
    /// `expire` header then expiration time will be checked against
    /// the current time to prevent unnecessary sending of already expired
    /// message.
    ///
    /// The `message already expired` error will be returned in this
    /// case.
    ///
    /// Note, that specifying `abi` for ABI compliant contracts is
    /// strongly recommended, so that proper processing strategy can be
    /// chosen.
    pub abi: Option<Abi>,

    pub thread_id: Option<String>,
    /// Flag for requesting events sending.
    /// Default is `false`.
    #[serde(default)]
    pub send_events: bool,
}

#[derive(Serialize, Deserialize, ApiType, Default, PartialEq, Debug)]
pub struct ResultOfSendMessage {
    // /// The last generated shard block of the message destination account before
    // the message was sent.
    //
    // This block id must be used as a parameter of the
    // `wait_for_transaction`.
    // pub shard_block_id: String,
    //
    // The list of endpoints to which the message was sent.
    //
    // This list id must be used as a parameter of the
    // `wait_for_transaction`.
    // pub sending_endpoints: Vec<String>,
    /// The hash of the processed message.
    pub message_hash: Option<String>,

    /// The hash of the block in which the message was included.
    pub block_hash: Option<String>,

    /// The hash of the transaction generated by the message.
    pub tx_hash: Option<String>,

    /// Returned values
    pub return_value: Option<Value>,

    /// The flag is set either if there is no action phase or if the action
    /// phase was unsuccessful.
    pub aborted: Option<bool>,

    /// The exit code of the computing phase
    pub exit_code: Option<i32>,

    /// The identifier of the thread in which the message was processed.
    pub thread_id: Option<String>,

    /// The list (IP addresses) of block producers processing the thread.
    pub producers: Vec<String>,

    /// The timestamp of generating this response.
    pub current_time: Option<String>,
}

#[derive(Clone)]
#[allow(dead_code)]
struct SendingMessage {
    serialized: String,
    deserialized: DeserializedObject<Message>,
    id: String,
    body: Vec<u8>,
    dst: MsgAddressInt,
    thread_id: ThreadIdentifier,
}

impl SendingMessage {
    fn new(
        context: &Arc<ClientContext>,
        serialized: &str,
        abi: Option<&Abi>,
        thread_id: Option<String>,
    ) -> ClientResult<Self> {
        // Check message
        let deserialized = deserialize_object_from_boc::<Message>(context, serialized, "message")?;
        let id = deserialized.cell.repr_hash().as_hex_string();
        let dst = deserialized.object.dst().ok_or(Error::message_has_not_destination_address())?;

        if let Some(expiration_time) =
            get_message_expiration_time(context.clone(), abi, serialized)?
        {
            if expiration_time <= context.env.now_ms() {
                return Err(Error::message_already_expired());
            }
        }
        let body = base64_decode(serialized)?;
        let thread_id = match thread_id {
            Some(t) => ThreadIdentifier::try_from(t).unwrap_or_default(),
            None => ThreadIdentifier::default(),
        };
        Ok(Self { serialized: serialized.to_string(), deserialized, id, body, dst, thread_id })
    }

    async fn send(&self, context: &Arc<ClientContext>) -> ClientResult<Value> {
        let net = context.get_server_link()?;
        let endpoint = net.state().get_query_endpoint().await?;
        net.send_message(&hex_decode(&self.id)?, &self.body, Some(&endpoint), self.thread_id).await
    }
}

pub async fn send_message<F: futures::Future<Output = ()> + Send>(
    context: Arc<ClientContext>,
    params: ParamsOfSendMessage,
    _callback: impl Fn(ProcessingEvent) -> F + Send + Sync + Clone,
) -> ClientResult<ResultOfSendMessage> {
    let message =
        SendingMessage::new(&context, &params.message, params.abi.as_ref(), params.thread_id)?;

    let result = message.send(&context).await?;

    if let Some(data) = result.get("data").and_then(|d| d.get("sendMessage")) {
        let mut res: ResultOfSendMessage =
            serde_json::from_value(data.clone()).map_err(Error::invalid_data)?;
        if let Some(abi) = params.abi {
            if let Ok(ext_out_msgs) = data.get_array("ext_out_msgs") {
                let msgs: Option<Vec<Value>> = ext_out_msgs
                    .iter()
                    .map(|body| decode_send_message_result(&context, abi.clone(), body))
                    .filter(|v| v.is_some())
                    .collect();

                res.return_value = msgs.and_then(|v| v.into_iter().next());
            }
        }

        Ok(res)
    } else {
        let err: ClientError =
            serde_json::from_value(result["error"].clone()).map_err(Error::invalid_data)?;
        Err(err)
    }
}

pub fn decode_send_message_result(
    context: &Arc<ClientContext>,
    abi: Abi,
    body: &Value,
) -> Option<Value> {
    body.as_str()
        .map(String::from)
        .and_then(|body| {
            decode_message_body(
                Arc::clone(context),
                ParamsOfDecodeMessageBody { abi, body, is_internal: false, ..Default::default() },
            )
            .ok()
        })
        .filter(|decoded| decoded.body_type == crate::abi::MessageBodyType::Output)
        .and_then(|decoded| decoded.value)
}
