// Copyright 2018-2021 TON Labs LTD.
//
// Licensed under the SOFTWARE EVALUATION License (the "License"); you may not
// use this file except in compliance with the License.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific TON DEV software governing permissions and
// limitations under the License.
//

use std::sync::Arc;

use serde_json::Value;
use tvm_block::Message;
use tvm_block::MsgAddressInt;

use super::ThreadIdentifier;
use crate::abi::Abi;
use crate::boc::internal::DeserializedObject;
use crate::boc::internal::deserialize_object_from_boc;
use crate::client::ClientContext;
use crate::encoding::base64_decode;
use crate::encoding::hex_decode;
use crate::error::ClientError;
use crate::error::ClientResult;
use crate::processing::Error;
use crate::processing::internal::get_message_expiration_time;
use crate::processing::types::ProcessingEvent;

#[derive(Serialize, Deserialize, ApiType, Default, Debug, Clone)]
pub struct ParamsOfSendMessage {
    /// Message BOC.
    pub message: String,

    /// Optional message ABI.
    ///
    /// If this parameter is specified and the message has the
    /// `expire` header then expiration time will be checked against
    /// the current time to prevent unnecessary sending of already expired
    /// message.
    ///
    /// The `message already expired` error will be returned in this
    /// case.
    ///
    /// Note, that specifying `abi` for ABI compliant contracts is
    /// strongly recommended, so that proper processing strategy can be
    /// chosen.
    pub abi: Option<Abi>,

    pub thread_id: ThreadIdentifier,
    /// Flag for requesting events sending.
    /// Default is `false`.
    #[serde(default)]
    pub send_events: bool,
}

#[derive(Serialize, Deserialize, ApiType, Default, PartialEq, Debug)]
pub struct ResultOfSendMessage {
    /* /// The last generated shard block of the message destination account before
    /// the message was sent.
    ///
    /// This block id must be used as a parameter of the
    /// `wait_for_transaction`.
    pub shard_block_id: String,

    /// The list of endpoints to which the message was sent.
    ///
    /// This list id must be used as a parameter of the
    /// `wait_for_transaction`.
    pub sending_endpoints: Vec<String>, */

    /// The hash of the processed message.
    pub message_hash: Option<String>,

    /// The hash of the block in which the message was included.
    pub block_hash: Option<String>,

    /// The hash of the transaction generated by the message.
    pub tx_hash: Option<String>,

    /// The flag is set either if there is no action phase or if the action
    /// phase was unsuccessful.
    pub aborted: Option<bool>,

    /// The exit code of the computing phase
    pub tvm_exit_code: Option<i32>,

    /// The identifier of the thread in which the message was processed.
    pub thread_id: Option<String>,

    /// The list (IP addresses) of block producers processing the thread.
    pub producers: Vec<String>,

    /// The timestamp of generating this response.
    pub current_time: Option<String>,
}

#[derive(Clone)]
struct SendingMessage {
    serialized: String,
    deserialized: DeserializedObject<Message>,
    id: String,
    body: Vec<u8>,
    dst: MsgAddressInt,
    thread_id: ThreadIdentifier,
}

impl SendingMessage {
    fn new(
        context: &Arc<ClientContext>,
        serialized: &str,
        abi: Option<&Abi>,
        thread_id: ThreadIdentifier,
    ) -> ClientResult<Self> {
        // Check message
        let deserialized = deserialize_object_from_boc::<Message>(context, serialized, "message")?;
        let id = deserialized.cell.repr_hash().as_hex_string();
        let dst = deserialized.object.dst().ok_or(Error::message_has_not_destination_address())?;

        let message_expiration_time =
            get_message_expiration_time(context.clone(), abi, serialized)?;
        if let Some(message_expiration_time) = message_expiration_time {
            if message_expiration_time <= context.env.now_ms() {
                return Err(Error::message_already_expired());
            }
        }
        let body = base64_decode(serialized)?;
        Ok(Self {
            serialized: serialized.to_string(),
            deserialized,
            id,
            body,
            dst,
            thread_id,
        })
    }

    async fn send(&self, context: &Arc<ClientContext>) -> ClientResult<Value> {
        let net = context.get_server_link()?;
        let endpoint = net.state().get_query_endpoint().await?;
        net.send_message(&hex_decode(&self.id)?, &self.body, Some(&endpoint), self.thread_id).await
    }
}

pub async fn send_message<F: futures::Future<Output = ()> + Send>(
    context: Arc<ClientContext>,
    params: ParamsOfSendMessage,
    _callback: impl Fn(ProcessingEvent) -> F + Send + Sync + Clone,
) -> ClientResult<ResultOfSendMessage> {
    let message = SendingMessage::new(
        &context,
        &params.message,
        params.abi.as_ref(),
        params.thread_id,
    )?;

    let result = message.send(&context).await;
    match result {
        Ok(value) => if value["data"].is_object() {
            let res: ResultOfSendMessage = serde_json::from_value(value["data"]["sendMessage"].clone())
                .map_err(Error::invalid_data)?;
            Ok(res)
        } else {
            let err: ClientError = serde_json::from_value(value["error"].clone())
                .map_err(Error::invalid_data)?;
            Err(err)
        },
        Err(err) => Err(err)
    }
}
