// Copyright 2018-2021 TON Labs LTD.
//
// Licensed under the SOFTWARE EVALUATION License (the "License"); you may not
// use this file except in compliance with the License.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific TON DEV software governing permissions and
// limitations under the License.
//

// 2022-2025 (c) Copyright Contributors to the GOSH DAO. All rights reserved.
//

use std::sync::Arc;

use serde::Deserialize;
use serde_json::Value;
use tvm_block::Message;
use tvm_block::MsgAddressInt;

use super::ThreadIdentifier;
use crate::abi::Abi;
use crate::abi::ParamsOfDecodeMessage;
use crate::abi::ParamsOfDecodeMessageBody;
use crate::abi::decode_message;
use crate::abi::decode_message_body;
use crate::boc::internal::DeserializedObject;
use crate::boc::internal::deserialize_object_from_boc;
use crate::client::ClientContext;
use crate::encoding::base64_decode;
use crate::error::ClientError;
use crate::error::ClientResult;
use crate::processing::Error;
use crate::processing::internal::get_message_expiration_time;
use crate::processing::types::ProcessingEvent;
use crate::utils::json::JsonHelper;

#[derive(Serialize, Deserialize, ApiType, Default, Debug, Clone)]
pub struct ParamsOfSendMessage {
    /// Message BOC.
    pub message: String,

    /// Optional message ABI.
    ///
    /// If this parameter is specified and the message has the
    /// `expire` header then expiration time will be checked against
    /// the current time to prevent unnecessary sending of already expired
    /// message.
    ///
    /// The `message already expired` error will be returned in this
    /// case.
    ///
    /// Note, that specifying `abi` for ABI compliant contracts is
    /// strongly recommended, so that proper processing strategy can be
    /// chosen.
    pub abi: Option<Abi>,

    pub thread_id: Option<String>,
    /// Flag for requesting events sending.
    /// Default is `false`.
    #[serde(default)]
    pub send_events: bool,
}

#[derive(Serialize, Deserialize, ApiType, Default, PartialEq, Debug)]
pub struct ResultOfSendMessage {
    // /// The last generated shard block of the message destination account before
    // the message was sent.
    //
    // This block id must be used as a parameter of the
    // `wait_for_transaction`.
    // pub shard_block_id: String,
    //
    // The list of endpoints to which the message was sent.
    //
    // This list id must be used as a parameter of the
    // `wait_for_transaction`.
    // pub sending_endpoints: Vec<String>,
    /// The hash of the processed message.
    pub message_hash: Option<String>,

    /// The hash of the block in which the message was included.
    pub block_hash: Option<String>,

    /// The hash of the transaction generated by the message.
    pub tx_hash: Option<String>,

    /// Returned values
    pub return_value: Option<Value>,

    /// The flag is set either if there is no action phase or if the action
    /// phase was unsuccessful.
    pub aborted: Option<bool>,

    /// The exit code of the computing phase
    pub exit_code: Option<i32>,

    /// The identifier of the thread in which the message was processed.
    pub thread_id: Option<String>,

    /// The list (IP addresses) of block producers processing the thread.
    pub producers: Vec<String>,

    /// The timestamp of generating this response.
    pub current_time: Option<String>,
}

#[derive(Clone)]
#[allow(dead_code)]
struct SendingMessage {
    serialized: String,
    deserialized: DeserializedObject<Message>,
    id: String,
    body: Vec<u8>,
    dst: MsgAddressInt,
    thread_id: ThreadIdentifier,
}

impl SendingMessage {
    fn new(
        context: &Arc<ClientContext>,
        serialized: &str,
        abi: Option<&Abi>,
        thread_id: Option<String>,
    ) -> ClientResult<Self> {
        // Check message
        let deserialized = deserialize_object_from_boc::<Message>(context, serialized, "message")?;

        let id = deserialized.cell.repr_hash().as_hex_string();
        let dst = deserialized.object.dst().ok_or(Error::message_has_not_destination_address())?;

        if let Some(expiration_time) =
            get_message_expiration_time(context.clone(), abi, serialized)?
        {
            if expiration_time <= context.env.now_ms() {
                return Err(Error::message_already_expired());
            }
        }
        let body = base64_decode(serialized)?;
        let thread_id = match thread_id {
            Some(t) => ThreadIdentifier::try_from(t).map_err(Error::invalid_thread)?,
            None => ThreadIdentifier::default(),
        };
        Ok(Self { serialized: serialized.to_string(), deserialized, id, body, dst, thread_id })
    }

    async fn send(&self, context: &Arc<ClientContext>) -> ClientResult<Value> {
        let server_link: &crate::net::ServerLink = context.get_server_link()?;
        server_link.send_message(&self.id, &self.body, self.thread_id, self.dst.clone()).await
    }
}

pub async fn send_message<F: futures::Future<Output = ()> + Send>(
    context: Arc<ClientContext>,
    params: ParamsOfSendMessage,
    _callback: impl Fn(ProcessingEvent) -> F + Send + Sync + Clone,
) -> ClientResult<ResultOfSendMessage> {
    let message =
        SendingMessage::new(&context, &params.message, params.abi.as_ref(), params.thread_id)?;

    let raw_result = message.send(&context).await?;

    match raw_result.get("result") {
        Some(result_value) if !result_value.is_null() => {
            let mut res: ResultOfSendMessage =
                serde_json::from_value(result_value.clone()).map_err(Error::invalid_data)?;

            if let Some(abi) = params.abi {
                if let Ok(ext_out_msgs) = result_value.get_array("ext_out_msgs") {
                    let msgs = ext_out_msgs
                        .iter()
                        .filter_map(|body| decode_send_message_result(&context, abi.clone(), body))
                        .collect::<Vec<_>>();

                    res.return_value = msgs.into_iter().next();
                }
            }

            Ok(res)
        }
        _ => {
            let err: ClientError = serde_json::from_value(
                raw_result
                    .get("error")
                    .cloned()
                    .ok_or_else(|| Error::invalid_data("Missing `error` field"))?,
            )
            .map_err(Error::invalid_data)?;
            Err(err)
        }
    }
}

pub fn decode_send_message_result(
    context: &Arc<ClientContext>,
    abi: Abi,
    body: &Value,
) -> Option<Value> {
    body.as_str()
        .map(String::from)
        .and_then(|body| {
            let decoded_message = decode_message(
                context.clone(),
                ParamsOfDecodeMessage {
                    abi: abi.clone(),
                    message: body.clone(),
                    ..Default::default()
                },
            );
            match decoded_message {
                Ok(message) => Some(message),
                Err(_) => decode_message_body(
                    Arc::clone(context),
                    ParamsOfDecodeMessageBody {
                        abi,
                        body,
                        is_internal: false,
                        ..Default::default()
                    },
                )
                .ok(),
            }
        })
        .filter(|decoded| decoded.body_type == crate::abi::MessageBodyType::Output)
        .and_then(|decoded| decoded.value)
}

#[cfg(test)]
mod test {
    use std::net::IpAddr;
    use std::net::SocketAddr;
    use std::sync::Arc;
    use std::time::Duration;

    use axum::Json;
    use axum::Router;
    use axum::body::Body;
    use axum::response::IntoResponse;
    use axum::routing::post;
    use if_addrs::get_if_addrs;
    use serde_json::json;
    use tokio::task::JoinHandle;

    use crate::ClientConfig;
    use crate::ClientContext;
    use crate::error::ClientError;
    use crate::net::NetworkConfig;
    use crate::processing::send_message::SendingMessage;

    // This helper function gets the external IP address of the host, for example
    // 192.168.1.20. For our test, we can use this address in addition to the
    // loopback interface.
    fn get_ext_ip() -> Option<IpAddr> {
        let addrs = get_if_addrs().ok()?;
        for iface in addrs {
            let ip = iface.ip();
            if let IpAddr::V4(ipv4) = ip {
                let octets = ipv4.octets();
                if ipv4.is_loopback() {
                    continue;
                }
                if octets[0] == 198 && (octets[1] == 18 || octets[1] == 19) {
                    continue;
                }
                return Some(IpAddr::V4(ipv4));
            }
        }
        None
    }

    async fn mock_server(socket_addr: SocketAddr) -> JoinHandle<()> {
        let socket_addr_clone = socket_addr.to_string();
        let app = Router::new().route(
            "/v2/messages",
            post(|_body: Body| async move {
                if socket_addr_clone == "127.0.0.1:9000" {   
                    let resp_json =  json!({
                        "result": null,
                        "error": {
                            "code": "WRONG_PRODUCER",
                            "message": "Resend message to the active Block Producer",
                            "data": {
                                "producers": vec![format!("{}:8600", get_ext_ip().unwrap().to_string())],
                                "message_hash": "77ac2790a7a20d90572c3c27c7725d0e0195440664d6bd7925a19fbe23ff3315",
                                "exit_code": null,
                                "current_time": "1748084498461",
                                "thread_id": "00000000000000000000000000000000000000000000000000000000000000000000"
                            }
                        },
                        "block_manager": {
                            "license_address": "0:8e8dad0462a4d5c528e18251846f24bc5c04cd1871115fb1e9b00c9741f60800",
                            "token": {
                                "unsigned": "1748084798476",
                                "signature": "c0c4fc73a9bab0f9d648eb1c2402d21a44559bf2a4b24f735f55a384d3a3914cbe2c9d1ed403ef548dded51c62510581b0dad96891ac6fa16af8687c7586b901",
                                "verifying_key": "e2c9d4be54d342d3f0e6394a7738fc39b93d4fe3fdba317aa699f7305566de2b"
                            }
                        }
                    });

                    Json(resp_json).into_response()
                } else {
                    Json(json!({"my_addr": socket_addr_clone})).into_response()
                }
            }),
        );

        let listener = tokio::net::TcpListener::bind(socket_addr).await.unwrap();
        let handle = tokio::spawn(async move {
            axum::serve(listener, app).await.unwrap();
        });
        // Allow the Axum server to start before continuing testing.
        tokio::time::sleep(Duration::from_secs(1)).await;
        handle
    }

    fn create_message(context: &Arc<ClientContext>) -> Result<SendingMessage, ClientError> {
        let boc = "te6ccgEBBQEA3gABRYgB0sAot7nO81FRdsdro5q5hNKjB6k6k6N0XXZSSbXxTUoMAQHh4AxQHiMp1/uMXYuNfGnJTSsq1DVvVlzApSGJkiF2orMR7b4l5EDxyH+tSUgEiCa+PjBmLMDnpf5H6LU1nLxSAcWYRhwySlz8mR2+azk8IhaQSMlY/kcFs4BX0+ppdawTwAAAZf1xorQaHASN34I/2WACAmWAHADCv78M71zAKAvf+gThFn5J+iUYEGTkeR5uVkByCnogAAAAAAAAAAAAAAAAAAAAEAwEAwAAABGgAAAAAhg9CQQ=";
        SendingMessage::new(context, boc, None, None)
    }

    #[tokio::test]
    async fn test_send_message_success() {
        let handle_0 = mock_server("127.0.0.1:8601".parse().unwrap()).await;
        let handle_1 = mock_server("127.0.0.1:9000".parse().unwrap()).await;

        let external_ip: IpAddr = get_ext_ip().unwrap();
        let external_socket = SocketAddr::new(external_ip, 8600);
        let handle_2 = mock_server(external_socket).await;

        // 1. Localhost ip, no port
        {
            let config = ClientConfig {
                network: NetworkConfig {
                    endpoints: Some(vec!["http://127.0.0.1:8601".to_string()]),
                    api_token: Some("secret".to_string()),
                    ..Default::default()
                },
                ..Default::default()
            };
            let client = Arc::new(ClientContext::new(config.clone()).unwrap());
            let message = create_message(&client).unwrap();
            let result = message.send(&client).await;
            assert_eq!(
                result.unwrap().to_string(),
                json!( {"my_addr": "127.0.0.1:8601"}).to_string()
            );
        }

        // 2. external_ip:8600.
        {
            let config = ClientConfig {
                network: NetworkConfig {
                    endpoints: Some(vec![format!("{external_ip}:8600")]),
                    api_token: Some("secret".to_string()),
                    ..Default::default()
                },
                ..Default::default()
            };
            let client = Arc::new(ClientContext::new(config.clone()).unwrap());
            let message = create_message(&client).unwrap();
            let result = message.send(&client).await;

            assert!(result.is_ok());
            assert_eq!(
                result.unwrap().to_string(),
                json!({"my_addr":  format!("{}:8600", get_ext_ip().unwrap())}).to_string()
            );
        }

        // 3. Localhost ip, specific port.
        // This server must redirect the client to external_ip:8600
        {
            let config = ClientConfig {
                network: NetworkConfig {
                    endpoints: Some(vec!["127.0.0.1:9000".to_string()]),
                    api_token: Some("secret".to_string()),
                    ..Default::default()
                },
                ..Default::default()
            };
            let client = Arc::new(ClientContext::new(config.clone()).unwrap());
            let message = create_message(&client).unwrap();
            let result = message.send(&client).await;

            assert!(result.is_ok());
            assert_eq!(
                result.unwrap().to_string(),
                json!({"my_addr":  format!("{}:8600", get_ext_ip().unwrap())}).to_string()
            );
        }
        handle_0.abort();
        handle_1.abort();
        handle_2.abort();
    }
}
